[
{
	"uri": "http://localhost:1313/cicd-ws/",
	"title": " DevOps Projects ",
	"tags": [],
	"description": "",
	"content": "Projects DevOps is a methodology that combines software development and IT operations to create a streamlined and automated development process. To achieve this, there are several tools that DevOps teams use to automate processes, manage infrastructure, and monitor applications\nIn this workshop, we will focus in some of DevOps tools:\nDevOps tools categorized: Version Control Systems (VCS): GitHub, GitLab Continuous Integration (CI) Tools: Jenkins, GitLab Containerization and Orchestration: Docker, Kubernetes Infrastructure as Code (IaC): Terraform Monitoring and Logging Tools: Prometheus, Zabbix, Grafana, ELK Stack Content Introduction Prepairation Configuration Cleanup "
},
{
	"uri": "http://localhost:1313/cicd-ws/3-config/3.3-labs/3.3.1-jenkins/3.3.1.1-cicd/",
	"title": "CI/CD",
	"tags": [],
	"description": "",
	"content": "Jenkins CICD is processing \u0026hellip;.\n"
},
{
	"uri": "http://localhost:1313/cicd-ws/2-prepair/2.1-docker/",
	"title": "Container",
	"tags": [],
	"description": "",
	"content": "A container is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries, and settings\nOverview Docker Docker is a platform that enables developers to build, package, ship, and run applications in containers. It provides tools and a platform to manage containerized applications across different environments, from development to production. Docker Compose Docker Compose is a tool provided by Docker that allows you to define and manage multi-container Docker applications. It uses a YAML file to configure the services, networks, and volumes required for your application Configuration Check the installed software\ndocker --version docker-compose --version Create a docker compose file to run the software on the container environment\ndocker-compose.yml version: \u0026#39;3\u0026#39;\rservices:\r# Terraform\rterraform:\rimage: hashicorp/terraform:latest\rvolumes:\r- .:/terraform\rworking_dir: /terraform\r# AWS CLI\u0026#39;\raws:\rimage: anigeo/awscli\renvironment:\rAWS_ACCESS_KEY_ID: \u0026#34;${AWS_ACCESS_KEY_ID}\u0026#34;\rAWS_SECRET_ACCESS_KEY: \u0026#34;${AWS_SECRET_ACCESS_KEY}\u0026#34;\rAWS_REGION: \u0026#34;${AWS_REGION}\u0026#34;\rAWS_DEFAULT_REGION: ap-southeast-1\rvolumes:\r- $PWD:/app\rworking_dir: /app "
},
{
	"uri": "http://localhost:1313/cicd-ws/3-config/3.1-ec2/",
	"title": "IaC",
	"tags": [],
	"description": "",
	"content": "In this Workshop we will create an EC2 instances with the information bellow\nOverview AWS EC2 Instances name: Web-Server VPC: 10.0.0.0/16 Subnets: 10.0.1.0/24 Region: Singapore (ap-southeast-1) Available zone: ap-southeast-1b Instance type: t2.micro Amazon Machine Images: Amazon Linux 2 AMI Key pair: tf-cli-keypair Security setting: Only allow my ip connect SSH to EC2 instance Allow all access from port 8080 to EC2 instance Terraform configuration Security credential variables: variables.tf\nvariable \u0026#34;access_key\u0026#34; {\rtype = string\rsensitive = true\r}\rvariable \u0026#34;secret_key\u0026#34; {\rtype = string\rsensitive = true\r}\rvariable \u0026#34;region\u0026#34; {\rtype = string\rdefault = \u0026#34;ap-southeast-1\u0026#34;\r} Instances configurations :main.tf\nvariable vpc_cidr_block {}\rvariable subnet_1_cidr_block {}\rvariable avail_zone {}\rvariable env_prefix {}\rvariable instance_type {}\rvariable my_ip {}\rvariable ami_id {}\rresource \u0026#34;aws_vpc\u0026#34; \u0026#34;myapp-vpc\u0026#34; {\rcidr_block = var.vpc_cidr_block\rtags = {\rName = \u0026#34;${var.env_prefix}-vpc\u0026#34;\r}\r}\rresource \u0026#34;aws_subnet\u0026#34; \u0026#34;myapp-subnet-1\u0026#34; {\rvpc_id = aws_vpc.myapp-vpc.id\rcidr_block = var.subnet_1_cidr_block\ravailability_zone = var.avail_zone\rtags = {\rName = \u0026#34;${var.env_prefix}-subnet-1\u0026#34;\r}\r}\rresource \u0026#34;aws_security_group\u0026#34; \u0026#34;myapp-sg\u0026#34; {\rname = \u0026#34;myapp-sg\u0026#34;\rvpc_id = aws_vpc.myapp-vpc.id\ringress {\rfrom_port = 22\rto_port = 22\rprotocol = \u0026#34;tcp\u0026#34;\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r}\ringress {\rfrom_port = 8080\rto_port = 8080\rprotocol = \u0026#34;tcp\u0026#34;\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\r}\regress {\rfrom_port = 0\rto_port = 0\rprotocol = \u0026#34;-1\u0026#34;\rcidr_blocks = [\u0026#34;0.0.0.0/0\u0026#34;]\rprefix_list_ids = []\r}\rtags = {\rName = \u0026#34;${var.env_prefix}-sg\u0026#34;\r}\r}\rresource \u0026#34;aws_internet_gateway\u0026#34; \u0026#34;myapp-igw\u0026#34; {\rvpc_id = aws_vpc.myapp-vpc.id\rtags = {\rName = \u0026#34;${var.env_prefix}-internet-gateway\u0026#34;\r}\r}\rresource \u0026#34;aws_route_table\u0026#34; \u0026#34;myapp-route-table\u0026#34; {\rvpc_id = aws_vpc.myapp-vpc.id\rroute {\rcidr_block = \u0026#34;0.0.0.0/0\u0026#34;\rgateway_id = aws_internet_gateway.myapp-igw.id\r}\r# default route, mapping VPC CIDR block to \u0026#34;local\u0026#34;, created implicitly and cannot be specified.\rtags = {\rName = \u0026#34;${var.env_prefix}-route-table\u0026#34;\r}\r}\r# Associate subnet with Route Table\rresource \u0026#34;aws_route_table_association\u0026#34; \u0026#34;a-rtb-subnet\u0026#34; {\rsubnet_id = aws_subnet.myapp-subnet-1.id\rroute_table_id = aws_route_table.myapp-route-table.id\r}\routput \u0026#34;server-ip\u0026#34; {\rvalue = aws_instance.myapp-server.public_ip\r}\rresource \u0026#34;aws_instance\u0026#34; \u0026#34;myapp-server\u0026#34; {\rami = var.ami_id\rinstance_type = var.instance_type\rkey_name = \u0026#34;tf-cli-keypair\u0026#34;\rassociate_public_ip_address = true\rsubnet_id = aws_subnet.myapp-subnet-1.id\rvpc_security_group_ids = [aws_security_group.myapp-sg.id]\ravailability_zone\t= var.avail_zone\rtags = {\rName = \u0026#34;${var.env_prefix}-server\u0026#34;\r}\r} Terraform provider AWS : terraform.tfvars\n# Network and Instance variables\rvpc_cidr_block = \u0026#34;10.0.0.0/16\u0026#34;\rsubnet_1_cidr_block = \u0026#34;10.0.1.0/24\u0026#34;\ravail_zone = \u0026#34;ap-southeast-1b\u0026#34;\renv_prefix = \u0026#34;web\u0026#34;\rmy_ip = \u0026#34;\u0026lt;myip\u0026gt;/32\u0026#34;\rami_id = \u0026#34;ami-04f73ca9a4310089f\u0026#34; Installation Terraform plan:\ndocker-compose run â€“rm terraform plan Terraform apply:\ndocker-compose run --rm terraform apply --auto-approve AWS Instance checking: Add Keypair permission:\nchmod 400 tf-cli-keypair.pem SSH to EC2 Instances:\nssh -i tf-cli-keypair.pem ec2-user@13.250.64.49 AWS Instance checking: "
},
{
	"uri": "http://localhost:1313/cicd-ws/1-intro/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "DevOps Projects Overview Continuous Integration and Continuous Deployment (CI/CD) is a cornerstone of DevOps methodology, emphasizing automation and collaboration throughout the software development lifecycle.\nContinuous Integration (CI): Developers regularly push code changes to a shared repository. Automated tests are run against the newly integrated code to ensure it doesn\u0026rsquo;t break existing functionality. If tests fail, developers are notified immediately, and they can address issues before they become larger problems. Continuous Deployment (CD): Once code changes pass the CI phase, they\u0026rsquo;re automatically deployed to production or staging environments. This process reduces manual intervention and ensures that new features or bug fixes reach users as quickly as possible. Content Introduction Prepairation Configure Cleanup "
},
{
	"uri": "http://localhost:1313/cicd-ws/3-config/3.3-labs/3.3.1-jenkins/3.3.1.2-advanced/",
	"title": "Advanced",
	"tags": [],
	"description": "",
	"content": "Jenkins advanced is processing \u0026hellip;.\n"
},
{
	"uri": "http://localhost:1313/cicd-ws/2-prepair/2.2-aws/",
	"title": "AWS",
	"tags": [],
	"description": "",
	"content": "Amazon Web Services (AWS) is a comprehensive and widely used cloud computing platform provided by Amazon. It offers a vast array of services, allowing individuals and businesses to build and deploy scalable applications and services without the need to invest in physical infrastructure\nOverview AWS CLI : The AWS Command Line Interface (CLI) is a powerful tool provided by Amazon Web Services (AWS) that allows you to interact with AWS services directly from your command line or terminal It provides a convenient and scriptable way to manage your AWS resources without needing to use the AWS Management Console Configuration Prepair and run docker compose file\ndocker-compose run --rm aws --version AWS: Create keypair to access AWS Instances: tf-cli-keypair.pem\ndocker-compose run --rm aws ec2 create-key-pair --key-name tf-cli-keypair --query \u0026#39;KeyMaterial\u0026#39; --output text \u0026gt; tf-cli-keypair.pem Create AWS Account for Terraform use AWS CLI: tf-cli\ndocker-compose run --rm aws iam create-user --user-name tf-cli AWS Checking keypair: Create Access Key \u0026amp; export to local\ndocker-compose run --rm aws iam create-access-key --user-name tf-cli \u0026gt; tf_cli-access_key.json Create policy and configure to allow access EC2 and Limit Region\nCreate a custom policy file: ec2-limited-access-policy.json {\r\u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;,\r\u0026#34;Statement\u0026#34;: [\r{\r\u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;,\r\u0026#34;Action\u0026#34;: \u0026#34;ec2:*\u0026#34;,\r\u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34;,\r\u0026#34;Condition\u0026#34;: {\r\u0026#34;StringEquals\u0026#34;: {\r\u0026#34;ec2:Region\u0026#34;: \u0026#34;ap-southeast-1\u0026#34;\r}\r}\r}\r]\r} Create a IAM policy: EC2FullAccessAPSouthEast1 docker-compose run --rm aws iam create-policy --policy-name EC2FullAccessAPSouthEast1 --policy-document file://ec2-limited-access-policy.json Attach the Policy to the IAM User: (tf-cli) docker-compose run --rm aws iam attach-user-policy --user-name tf-cli --policy-arn arn:aws:iam::637423373411:policy/EC2FullAccessAPSouthEast1 AWS Checking User: "
},
{
	"uri": "http://localhost:1313/cicd-ws/3-config/3.2-jenkins/",
	"title": "CICD",
	"tags": [],
	"description": "",
	"content": "Updating \u0026hellip;.\n"
},
{
	"uri": "http://localhost:1313/cicd-ws/2-prepair/",
	"title": "Prepairation",
	"tags": [],
	"description": "",
	"content": "Diagram Workshop - 0001 In this lab, we will be automate deploy a Server in AWS Cloud with tools: AWS CLI, Docker Compose, Terraform. Server Name: Web-Server Deploy processing: follow link Contents Docker AWS Teraform Git Local "
},
{
	"uri": "http://localhost:1313/cicd-ws/3-config/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " The Projects for the workshop \u0026hellip;.. Content IaC CICD Labs "
},
{
	"uri": "http://localhost:1313/cicd-ws/3-config/3.3-labs/3.3.1-jenkins/",
	"title": "Jenkins",
	"tags": [],
	"description": "",
	"content": "Overview Jenkins is an open-source automation server that is widely used for automating software development processes such as building, testing, and deploying applications. It allows developers to automate repetitive tasks associated with the software development lifecycle, thereby saving time and reducing errors.\nJenkins Server Installation Login vagrant ssh machine2 Install Jenkins server in Linux project is processing \u0026hellip; Install Jenkins server running in docker container Prepair sudo -i\rapt update\rmkdir /tools\rcd /tools\rmkdir docker\rcd docker\rvi install-docker.sh File content: install-docker.sh\n#!/bin/bash sudo apt update sudo apt install -y apt-transport-https ca-certificates curl software-properties-common curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg echo \u0026#34;deb [signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null sudo apt update sudo apt install -y docker-ce sudo systemctl start docker sudo systemctl enable docker sudo curl -L \u0026#34;https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)\u0026#34; -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose docker --version docker-compose --version Install chmod +x install-docker.sh\rsh install-docker.sh Create Docker compose file mkdir /tools/jenkins\rcd /tools/jenkins\rvi docker-compose.yml version: \u0026#39;3\u0026#39; services: # Jenkins jenkins: container_name: jenkins image: jenkins/jenkins ports: - \u0026#34;8080:8080\u0026#34; volumes: - jenkins_home:/var/jenkins_home volumes: jenkins_home: Run Jenkins Server docker-compose up jenkins -d Configuration Jenkins Server: Login: http://192.168.33.110:8080 Configuration ## Admin password: docker exec -it jenkins cat /var/jenkins_home/secrets/initialAdminPassword Overview Content Jenkins CICD Advanced "
},
{
	"uri": "http://localhost:1313/cicd-ws/3-config/3.3-labs/",
	"title": "Labs",
	"tags": [],
	"description": "",
	"content": "Devops projects are processing \u0026hellip;.\nContent Jenkins GitLab "
},
{
	"uri": "http://localhost:1313/cicd-ws/2-prepair/2.3-terraform/",
	"title": "Terraform",
	"tags": [],
	"description": "",
	"content": "Terraform is a open-source tool used to build, modify, and version control infratrucrure\nOverview Provider(provider.tf): Enables Terrafrom to interact with cloud providers and other APIs Terraform (versions.tf): Sets version constaints for Terraform and optionally maps provides to a source address and version constaint Variables (variable.tf): Input variables define reusable values and work like function arguments in general-purpose programming languages Resource (main.tf): Resource blocks describe infrastructure objects like VPCs, subnets, route tables, and gateways Data : Data sources allow Terraform to ultilize information form resources that were defined outside of Terraform (or defined a different Terraform configuration) Output: Outputs return structured data form your configuration and work like return values in generaral-purpose programming languages Terraform.tfvars: To set lots of variables, it is more convenient to specify their values in a variable definitions file Command terraform init [options]: command initializes a working directory containing Terraform configuration files. terraform plan [options]: command creates an execution plan, which lets you preview the changes that Terraform plans to make to your infrastructure. terraform apply [options] [plan file]: command executes the actions proposed in a Terraform plan terraform destroy [options]: command is a convenient way to destroy all remote objects managed by a particular Terraform configuration. Run Terraform in containter: Run docker compose:\ndocker-compose run --rm terraform version Run configure:\nProvider (AWS): versions.tf\nterraform {\rrequired_providers {\raws = {\rsource = \u0026#34;hashicorp/aws\u0026#34;\rversion = \u0026#34;~\u0026gt; 4.16\u0026#34;\r}\r}\rrequired_version = \u0026#34;\u0026gt;= 1.2.0\u0026#34;\r} Security credential variables: variables.tf\nvariable \u0026#34;access_key\u0026#34; {\rtype = string\rsensitive = true\r}\rvariable \u0026#34;secret_key\u0026#34; {\rtype = string\rsensitive = true\r}\rvariable \u0026#34;region\u0026#34; {\rtype = string\rdefault = \u0026#34;ap-southeast-1\u0026#34;\r} Terraform init:\ndocker-compose run --rm terraform init "
},
{
	"uri": "http://localhost:1313/cicd-ws/2-prepair/2.4-git/",
	"title": "Git",
	"tags": [],
	"description": "",
	"content": "Git is a distributed version control system (DVCS) that helps developers track changes to source code during software development. It allows multiple developers to collaborate on projects simultaneously.\nOverview Github GitHub is a web-based platform built on top of Git, the distributed version control system. It offers a variety of features to help developers collaborate on software projects GitHub provides a platform for hosting Git repositories. Developers can create new repositories to store their code, either publicly (visible to everyone) or privately (accessible only to authorized collaborators) Configuration Create Github Repository and Access\nCreate a public repo: https://github.com/nonotnonez/ws-0001\nCreate Github Access Key : https://github.com/settings/tokens\nName: github_token_ws Expiration:\t90 days Select scopes: repo workflow Clone Source form Github: git clone https://**token**@github.com/NoNotNonez/ws-0001.git\nCopy Source code to Github Repo:\ncd /ws-0001/terraform Create .gitignore:\nto security and prevent important file upload to github Push Source code to Git Repo:\ngit status git add . git commit -m \u0026ldquo;Add Tf source\u0026rdquo; git push "
},
{
	"uri": "http://localhost:1313/cicd-ws/3-config/3.3-labs/3.3.2-gitlab/",
	"title": "Gitlabs",
	"tags": [],
	"description": "",
	"content": "Gitlab is processing \u0026hellip;.\n"
},
{
	"uri": "http://localhost:1313/cicd-ws/4-cleanup/4.1-ec2/",
	"title": "IaC",
	"tags": [],
	"description": "",
	"content": "Clean up resources We will process to clearn up all the resources\nTerraform: Run docker compose:\ndocker-compose run --rm terraform destroy --auto-approve AWS Checking "
},
{
	"uri": "http://localhost:1313/cicd-ws/4-cleanup/",
	"title": "Resource Cleanup",
	"tags": [],
	"description": "",
	"content": "Clean up resources All processing to clearn up all the resources\nContent IAC CICD "
},
{
	"uri": "http://localhost:1313/cicd-ws/4-cleanup/4.2-jenkins/",
	"title": "CICD",
	"tags": [],
	"description": "",
	"content": "We are processing \u0026hellip;.\n"
},
{
	"uri": "http://localhost:1313/cicd-ws/2-prepair/2.5-local/",
	"title": "Local",
	"tags": [],
	"description": "",
	"content": "Overview We will use local environment with Vagrant and VirtualBox to test best practices.\nVagrant Vagrant is an open-source tool for building and managing virtualized development environments. It helps developers create and configure reproducible and portable development environments that closely mimic production setups. Virtualbox VirtualBox is a powerful open-source virtualization software developed by Oracle Corporation. It allows users to run multiple guest operating systems (OS) simultaneously on a single physical machine. Configuration Requirement\nMachine 1: Linux-server IP: 192.168.33.100 Memory: 2048 Mb Machine 2: Jenkins-server IP: 192.168.33.110 Memory: 5120 Mb Machine 3: Monitor-server IP: 192.168.33.120 Memory: 2048 Mb Vagrantfile\n# -*- mode: ruby -*-\r# vi: set ft=ruby :\rVagrant.configure(\u0026#34;2\u0026#34;) do |config|\rconfig.vm.box = \u0026#34;ubuntu/focal64\u0026#34;\r# Configuration for the first virtual machine\rconfig.vm.define \u0026#34;machine1\u0026#34; do |machine1|\rmachine1.vm.network \u0026#34;private_network\u0026#34;, ip: \u0026#34;192.168.33.100\u0026#34;\rmachine1.vm.hostname = \u0026#34;linux-server\u0026#34;\rmachine1.vm.provider \u0026#34;virtualbox\u0026#34; do |vb|\rvb.memory = \u0026#34;2048\u0026#34;\rend\rmachine1.vm.synced_folder \u0026#34;./datas\u0026#34;, \u0026#34;/vagrant_data\u0026#34; end\r# Configuration for the second virtual machine\rconfig.vm.define \u0026#34;machine2\u0026#34; do |machine2|\rmachine2.vm.network \u0026#34;private_network\u0026#34;, ip: \u0026#34;192.168.33.110\u0026#34;\rmachine2.vm.hostname = \u0026#34;jenkins-server\u0026#34;\rmachine2.vm.provider \u0026#34;virtualbox\u0026#34; do |vb|\rvb.memory = \u0026#34;5120\u0026#34;\rend\rmachine2.vm.synced_folder \u0026#34;./datas\u0026#34;, \u0026#34;/vagrant_data\u0026#34;\rend\r# Configuration for the third virtual machine\rconfig.vm.define \u0026#34;machine3\u0026#34; do |machine3|\rmachine3.vm.network \u0026#34;private_network\u0026#34;, ip: \u0026#34;192.168.33.120\u0026#34;\rmachine3.vm.hostname = \u0026#34;monitor-server\u0026#34;\rmachine3.vm.provider \u0026#34;virtualbox\u0026#34; do |vb|\rvb.memory = \u0026#34;2048\u0026#34;\rend\rmachine3.vm.synced_folder \u0026#34;./datas\u0026#34;, \u0026#34;/vagrant_data\u0026#34; machine3.vm.provision \u0026#34;shell\u0026#34;, inline: \u0026lt;\u0026lt;-SHELL\rapt-get update\rSHELL\rend\rend Installation\nvagrant up vagrant status vagrant ssh "
},
{
	"uri": "http://localhost:1313/cicd-ws/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/cicd-ws/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]